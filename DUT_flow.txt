1. Reset sequence
    - initialise all output ports to 0
    - AWREADY, ARREADY, BREADY & RREADY set to 1 as default

2. Write request channel (AW)
    - when both AWVALID && AWREADY are asserted, store AWADDR, AWID, AWLEN, AWSIZE & AWBURST into respective local registers
    - LEN + 1: indicate total number of beat transfers
    - SIZE: 2^SIZE bytes size for each beat
    - BURST: 2'b01 = INCR, 2'b10 = WRAP, 2'b00 = FIXED

3. Write data channel (W)
    - when both WVALID && WREADY asserted, store WDATA in local memory array
    - to also consider WSTRB (each bit of WSTRB controls every 8-bit of WDATA)
        WSTRB[0] -> WDATA[7:0]
        WSTRB[1] -> WDATA[15:8]
        WSTRB[2] -> WDATA[23:16]
        WSTRB[3] -> WDATA[31:24]
        WSTRB[i] -> WDATA[(i+1)*8-1:i*8]
    - assert WLAST when last beat is transferred

4. Write response channel (B)
    - when both BVALID && BREADY asserted -> write transaction complete
    - BRESP == 2'b00 (OKAY) to indicate successful transfer

5. Read request channel (AR)
    - when both ARVALID and ARREADY asserted, store ARADDR, ARID, ARLEN, ARSIZE & ARBURST into respective local registers

6. Read data channel (R)
    - when both RVALID and RREADY asserted, fetch value from local mem_array and place into RDATA
    - assert RLAST during last beat transfer
    - when RLAST asserted, RRESP == 2'b00 (OKAY) to indicate successful transfer